==============Brute Force================
======Python=====
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [1]*n
        for i in range(n):
            product = 1
            for j in range(n):
                if i!=j:
                    product *= nums[j]
            res[i] = product
        return res
        
=====Golang=======
func productExceptSelf(nums []int) []int {
    n := len(nums)
    res := make([]int,n)
    for i:=0;i<n;i++{
        product := 1
        for j:=0;j<n;j++{
            if i!=j{
            product *= nums[j]
            }
        }
        res[i]=product
    }
    return res   
}


===============Optimized======================
=====Python=====
class Solution(object):
    def productExceptSelf(self, nums):
        n = len(nums)
        lpsum = [1]*n
        for i in range(1,n):
            lpsum[i] = nums[i-1]* lpsum[i-1]
        
        rpsum =[1]*n
        for j in range(n-2,-1,-1):
            rpsum[j] = nums[j+1]*rpsum[j+1]
        
        res = [1]*n
        for i in range(n):
            res[i]=lpsum[i]*rpsum[i]

        return res



====Golang====
func fill(val int,n int) []int{
    slice := make([]int,n)
    for i := range slice{
        slice[i]=val
    }
    return slice
}

func productExceptSelf(nums []int) []int {
    n := len(nums)

    lsum := fill(1,n)
    rsum := fill(1,n)

    //lsum
    for i:=1;i<n;i++{
        lsum[i] = nums[i-1]*lsum[i-1]
    }

    //rsum
    for j:=n-2;j>-1;j--{
        rsum[j] = nums[j+1]*rsum[j+1]
    }

    res := make([]int,n)
    //for i := range res{
    for i := 0;i<n;i++{
        res[i]=lsum[i]*rsum[i]
    }
    return res
}